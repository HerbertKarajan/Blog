(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{413:function(t,s,a){"use strict";a.r(s);var e=a(1),r=Object(e.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"_11-面试问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_11-面试问题"}},[t._v("#")]),t._v(" 11. 面试问题")]),t._v(" "),a("p"),a("div",{staticClass:"table-of-contents"},[a("ul",[a("li",[a("a",{attrs:{href:"#_1-css文件放在首部还是底部"}},[t._v("1. css文件放在首部还是底部")]),a("ul",[a("li",[a("a",{attrs:{href:"#提高性能的九个技巧"}},[t._v("提高性能的九个技巧")])])])]),a("li",[a("a",{attrs:{href:"#_2-translate会造成重绘么？"}},[t._v("2. translate会造成重绘么？")]),a("ul",[a("li",[a("a",{attrs:{href:"#总结"}},[t._v("总结")])])])]),a("li",[a("a",{attrs:{href:"#_3-为什么要减少http请求"}},[t._v("3. 为什么要减少HTTP请求")])]),a("li",[a("a",{attrs:{href:"#_4-垃圾回收算法优缺点"}},[t._v("4. 垃圾回收算法优缺点")]),a("ul",[a("li",[a("a",{attrs:{href:"#引用计数法"}},[t._v("引用计数法")])]),a("li",[a("a",{attrs:{href:"#标记清除算法"}},[t._v("标记清除算法")])])])])])]),a("p"),t._v(" "),a("h2",{attrs:{id:"_1-css文件放在首部还是底部"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-css文件放在首部还是底部"}},[t._v("#")]),t._v(" 1. css文件放在首部还是底部")]),t._v(" "),a("ul",[a("li",[t._v("CSS 不会阻塞 DOM 的解析，但会阻塞 DOM 渲染。如果不阻塞DOM渲染用户体验可谓极差，可能会渲染多次，而且渲染是有成本的。因此，基于性能与用户体验的考虑，浏览器会尽量减少渲染的次数，CSS顺理成章地阻塞页面渲染。")]),t._v(" "),a("li",[t._v('JS 阻塞 DOM 解析，但浏览器会"偷看"DOM，预先下载相关资源。')]),t._v(" "),a("li",[t._v("浏览器遇到 "),a("code",[t._v("<script>")]),t._v("且没有"),a("code",[t._v("defer")]),t._v("或"),a("code",[t._v("async")]),t._v("属性的标签时，会触发页面渲染，因而如果"),a("strong",[t._v("前面CSS资源")]),t._v("尚未加载完毕时，浏览器会等待它加载完毕在执行脚本。因为js脚本中可能会获取计算样式，需要等待css加载后执行。"),a("code",[t._v("defer")]),t._v("被设定用来通知浏览器该脚本将在文档完成解析后，触发 "),a("code",[t._v("DOMContentLoaded")]),t._v(" 事件前执行。")])]),t._v(" "),a("p",[t._v("所以，你现在明白为何"),a("code",[t._v("<script>")]),t._v("最好放底部，"),a("code",[t._v("<link>")]),t._v("最好放头部，如果头部同时有"),a("code",[t._v("<script>")]),t._v("与"),a("code",[t._v("<link>")]),t._v("的情况下，最好将"),a("code",[t._v("<script>")]),t._v("放在"),a("code",[t._v("<link>")]),t._v("上面了吗？")]),t._v(" "),a("p",[a("strong",[t._v("放在底部可能会造成以下问题：")])]),t._v(" "),a("ul",[a("li",[t._v("可能造成js计算样式不对")]),t._v(" "),a("li",[t._v("阻塞DOM解析")])]),t._v(" "),a("h3",{attrs:{id:"提高性能的九个技巧"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#提高性能的九个技巧"}},[t._v("#")]),t._v(" 提高性能的九个技巧")]),t._v(" "),a("p",[t._v("第一条，DOM 的多个读操作（或多个写操作），应该放在一起。不要两个读操作之间，加入一个写操作。"),a("br"),t._v("\n第二条，如果某个样式是通过重排得到的，那么最好缓存结果。避免下一次用到的时候，浏览器又要重排。"),a("br"),t._v("\n第三条，不要一条条地改变样式，而要通过改变class，或者csstext属性，一次性地改变样式。")]),t._v(" "),a("div",{staticClass:"language-css line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-css"}},[a("code",[t._v("// bad\nvar left = 10"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nvar top = 10"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nel.style.left = left + "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"px"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nel.style.top  = top  + "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"px"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n// good \nel.className += "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('" theclassname"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n// good\nel.style.cssText += "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"; left: "')]),t._v(" + left + "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"px; top: "')]),t._v(" + top + "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"px;"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br"),a("span",{staticClass:"line-number"},[t._v("7")]),a("br"),a("span",{staticClass:"line-number"},[t._v("8")]),a("br"),a("span",{staticClass:"line-number"},[t._v("9")]),a("br"),a("span",{staticClass:"line-number"},[t._v("10")]),a("br"),a("span",{staticClass:"line-number"},[t._v("11")]),a("br")])]),a("p",[t._v("第四条，尽量使用离线DOM，而不是真实的网面DOM，来改变元素样式。比如，操作Document Fragment对象，完成后再把这个对象加入DOM。再比如，使用 cloneNode() 方法，在克隆的节点上进行操作，然后再用克隆的节点替换原始节点。"),a("br"),t._v("\n第五条，先将元素设为"),a("code",[t._v("display: none")]),t._v("（需要1次重排和重绘），然后对这个节点进行100次操作，最后再恢复显示（需要1次重排和重绘）。这样一来，你就用两次重新渲染，取代了可能高达100次的重新渲染。"),a("br"),t._v("\n第六条，position属性为absolute或fixed的元素，重排的开销会比较小，因为不用考虑它对其他元素的影响。"),a("br"),t._v("\n第七条，只在必要的时候，才将元素的display属性为可见，因为不可见的元素不影响重排和重绘。另外，"),a("code",[t._v("visibility : hidden")]),t._v("的元素只对重绘有影响，不影响重排。"),a("br"),t._v("\n第八条，使用虚拟DOM的脚本库，比如React等。"),a("br"),t._v("\n第九条，使用 "),a("code",[t._v("window.requestAnimationFrame()")]),t._v(" 这两个方法调节重新渲染。")]),t._v(" "),a("p",[a("a",{attrs:{href:"https://www.ruanyifeng.com/blog/2015/09/web-page-performance-in-depth.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://www.ruanyifeng.com/blog/2015/09/web-page-performance-in-depth.html"),a("OutboundLink")],1),t._v(" "),a("a",{attrs:{href:"https://juejin.im/post/59c60691518825396f4f71a1#heading-2",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://juejin.im/post/59c60691518825396f4f71a1#heading-2"),a("OutboundLink")],1)]),t._v(" "),a("h2",{attrs:{id:"_2-translate会造成重绘么？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-translate会造成重绘么？"}},[t._v("#")]),t._v(" 2. translate会造成重绘么？")]),t._v(" "),a("p",[t._v("left/top/margin 之类的属性会影响到元素在文档中的布局，当对布局（layout）进行动画时，该元素的布局改变可能会影响到其他元素在文档中的位置，就导致了所有被影响到的元素都要进行重新布局，浏览器需要为整个层进行重绘并重新上传到 GPU，造成了极大的性能开销。")]),t._v(" "),a("p",[t._v("transform 属于合成属性（composite property），对合成属性进行 transition/animation 动画将会创建一个合成层（composite layer），这使得被动画元素在一个独立的层中进行动画。通常情况下，浏览器会将一个层的内容先绘制进一个位图中，然后再作为纹理（texture）上传到 GPU，只要该层的内容不发生改变，就没必要进行重绘（repaint），浏览器会通过重新复合（recomposite）来形成一个新的帧。")]),t._v(" "),a("p",[a("strong",[t._v("层创立的条件如下：")])]),t._v(" "),a("ul",[a("li",[t._v("3D 或透视变换 CSS 属性")]),t._v(" "),a("li",[t._v("使用加速视频解码的 "),a("code",[t._v("<video>")])]),t._v(" "),a("li",[t._v("元素拥有 3D (WebGL) 上下文或加速的 2D 上下文的 "),a("code",[t._v("<canvas>")]),t._v(" 元素")]),t._v(" "),a("li",[t._v("复合插件(如 Flash)进行 opacity/transform 动画的元素")]),t._v(" "),a("li",[t._v("拥有加速 CSS filters 的元素")]),t._v(" "),a("li",[t._v("元素有一个包含复合层的后代节点(换句话说，就是一个元素拥有一个子元素，该子元素在自己的层里)元素有一个 z-index 较低且包含一个复合层的兄弟元素(换句话说就是该元素在复合层上面渲染)")])]),t._v(" "),a("h3",{attrs:{id:"总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),a("ul",[a("li",[t._v("对布局属性进行动画，浏览器需要为每一帧进行重绘并上传到 GPU 中")]),t._v(" "),a("li",[t._v("对合成属性进行动画，浏览器会为元素创建一个独立的复合层，当元素内容没有发生改变，该层就不会被重绘，浏览器会通过重新复合来创建动画帧。")])]),t._v(" "),a("p",[t._v("链接："),a("a",{attrs:{href:"https://www.zhihu.com/question/33629083/answer/57062375",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://www.zhihu.com/question/33629083/answer/57062375"),a("OutboundLink")],1)]),t._v(" "),a("h2",{attrs:{id:"_3-为什么要减少http请求"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-为什么要减少http请求"}},[t._v("#")]),t._v(" 3. 为什么要减少HTTP请求")]),t._v(" "),a("p",[a("strong",[t._v("好处：")])]),t._v(" "),a("ul",[a("li",[t._v("减少http请求头的数据量")]),t._v(" "),a("li",[t._v("减少http连接的开销")]),t._v(" "),a("li",[t._v("会显著增加浏览器和服务器的网络资源消耗")])]),t._v(" "),a("p",[a("strong",[t._v("坏处：")])]),t._v(" "),a("ul",[a("li",[t._v("多个请求放到一个请求中，只要TCP丢了一个包，TCP自然会重传，需要T1时间，就会造成页面加载时间增加T1")]),t._v(" "),a("li",[t._v("缓存失效率就越高，浏览器缓存利用率相对偏低。")])]),t._v(" "),a("p",[t._v("推荐2-6个合并")]),t._v(" "),a("p",[a("a",{attrs:{href:"https://blog.csdn.net/chenchun91/article/details/52207008",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://blog.csdn.net/chenchun91/article/details/52207008"),a("OutboundLink")],1)]),t._v(" "),a("h2",{attrs:{id:"_4-垃圾回收算法优缺点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-垃圾回收算法优缺点"}},[t._v("#")]),t._v(" 4. 垃圾回收算法优缺点")]),t._v(" "),a("h3",{attrs:{id:"引用计数法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#引用计数法"}},[t._v("#")]),t._v(" 引用计数法")]),t._v(" "),a("p",[t._v("假设有一个对象A，任何一个对象对A的引用，那么对象A的引用计数器+1，当引用失败时，对象A的引用计数器就-1，如果对象A的计算器的值\n为0，就说明对象A没有引用了，可以被回收。")]),t._v(" "),a("p",[a("strong",[t._v("优点 ：")]),t._v("\n1、可即刻回收垃圾。\n2、在垃圾回收过程中，应用无需挂起。如果申请内存时，内存不足，则立刻报outofmember错误。"),a("br"),t._v("\n3、区域性，更新对象的计数器时，只是影响到该对象，不会扫描全部对象。")]),t._v(" "),a("p",[a("strong",[t._v("缺点 ：")]),a("br"),t._v("\n1、每次对象被引用时，都需要去更新计数器，有一点时间开销。"),a("br"),t._v("\n2、浪费CPU资源，即使内存够用，仍然在运行时进行计数器的统计。"),a("br"),t._v("\n3、无法解决循环引用问题。（最大的缺点）")]),t._v(" "),a("h3",{attrs:{id:"标记清除算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#标记清除算法"}},[t._v("#")]),t._v(" 标记清除算法")]),t._v(" "),a("p",[t._v("将垃圾回收分为2个阶段，分别是标记和清除。")]),t._v(" "),a("p",[t._v("标记 ：从根节点开始标记引用的对象。"),a("br"),t._v("\n清除 ：未被标记引用的对象就是垃圾对象，可以被清理。")]),t._v(" "),a("p",[a("strong",[t._v("优点")]),a("br"),t._v("\n标记清除算法解决了引用计数算法中的循环引用的问题，没有从root节点引用的对象都会被回收。")]),t._v(" "),a("p",[a("strong",[t._v("缺点：")]),a("br"),t._v("\n1、效率较低，标记和清除两个动作都需要遍历所有的对象，并且在GC时，需要停止应用程序，对于交互性要求比较高的应用\n而言这个体验是非常差的。"),a("br"),t._v("\n2、通过标记清除算法清理出来的内容，碎片化较为严重，因为被回收的对象可能存在于内存的各个角落，所以清理出来的内存是不连贯的。")])])}),[],!1,null,null,null);s.default=r.exports}}]);